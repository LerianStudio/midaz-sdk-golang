//nolint:revive // test file must be in same package as code under test
package utils

import (
	"testing"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestNewUUID(t *testing.T) {
	// Generate a new UUID
	id := NewUUID()

	// Verify it's not empty
	assert.NotEmpty(t, id)

	// Verify it's a valid UUID format
	_, err := uuid.Parse(id)
	require.NoError(t, err)

	// Verify it's a version 4 UUID (random)
	parsedUUID, _ := uuid.Parse(id)
	assert.Equal(t, uuid.Version(4), parsedUUID.Version())
}

func TestNewUUIDUniqueness(t *testing.T) {
	// Generate multiple UUIDs and verify they're unique
	numUUIDs := 1000
	uuids := make(map[string]bool)

	for i := 0; i < numUUIDs; i++ {
		id := NewUUID()

		// Check that this UUID hasn't been seen before
		if uuids[id] {
			t.Errorf("Duplicate UUID generated: %s", id)
		}

		uuids[id] = true
	}

	assert.Len(t, uuids, numUUIDs, "All generated UUIDs should be unique")
}

func TestIsValidUUID(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected bool
	}{
		{
			name:     "valid UUID v4",
			input:    "550e8400-e29b-41d4-a716-446655440000",
			expected: true,
		},
		{
			name:     "valid UUID v1",
			input:    "12345678-1234-1234-1234-123456789012",
			expected: true,
		},
		{
			name:     "valid UUID with uppercase",
			input:    "550E8400-E29B-41D4-A716-446655440000",
			expected: true,
		},
		{
			name:     "invalid UUID - too short",
			input:    "550e8400-e29b-41d4-a716-44665544000",
			expected: false,
		},
		{
			name:     "invalid UUID - too long",
			input:    "550e8400-e29b-41d4-a716-4466554400000",
			expected: false,
		},
		{
			name:     "invalid UUID - missing hyphens",
			input:    "550e8400e29b41d4a716446655440000",
			expected: false,
		},
		{
			name:     "invalid UUID - wrong hyphen positions",
			input:    "550e840-0e29b-41d4-a716-446655440000",
			expected: false,
		},
		{
			name:     "invalid UUID - non-hex characters",
			input:    "550g8400-e29b-41d4-a716-446655440000",
			expected: false,
		},
		{
			name:     "empty string",
			input:    "",
			expected: false,
		},
		{
			name:     "nil UUID",
			input:    "00000000-0000-0000-0000-000000000000",
			expected: true, // Nil UUID is still a valid UUID format
		},
		{
			name:     "random string",
			input:    "not-a-uuid",
			expected: false,
		},
		{
			name:     "UUID with extra characters",
			input:    "550e8400-e29b-41d4-a716-446655440000-extra",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := IsValidUUID(tt.input)
			assert.Equal(t, tt.expected, result, "IsValidUUID(%s) should return %v", tt.input, tt.expected)
		})
	}
}

func TestIsValidUUIDWithGeneratedUUIDs(t *testing.T) {
	// Test that all UUIDs generated by NewUUID are valid
	for i := 0; i < 100; i++ {
		id := NewUUID()
		assert.True(t, IsValidUUID(id), "Generated UUID should be valid: %s", id)
	}
}

func TestValidateMetadata(t *testing.T) {
	tests := []struct {
		name      string
		metadata  map[string]any
		expectErr bool
	}{
		{
			name:      "nil metadata",
			metadata:  nil,
			expectErr: false,
		},
		{
			name:      "empty metadata",
			metadata:  map[string]any{},
			expectErr: false,
		},
		{
			name: "valid metadata with string values",
			metadata: map[string]any{
				"key1": "value1",
				"key2": "value2",
			},
			expectErr: false,
		},
		{
			name: "valid metadata with different types",
			metadata: map[string]any{
				"string_key": "string_value",
				"int_key":    42,
				"float_key":  3.14,
				"bool_key":   true,
			},
			expectErr: false,
		},
		{
			name: "valid metadata with reasonable key length",
			metadata: map[string]any{
				"this_is_a_reasonable_key": "value",
			},
			expectErr: false,
		},
		{
			name: "valid metadata with reasonable value length",
			metadata: map[string]any{
				"key": "this is a reasonable value that should not cause any issues with validation",
			},
			expectErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := ValidateMetadata(tt.metadata)

			if tt.expectErr {
				require.Error(t, err, "Expected validation error for metadata: %v", tt.metadata)
			} else {
				require.NoError(t, err, "Expected no validation error for metadata: %v", tt.metadata)
			}
		})
	}
}

func TestValidateMetadataWithExtremeValues(t *testing.T) {
	// Test with very long key (should fail if validation enforces key length limits)
	longKey := string(make([]byte, 200)) // 200 character key
	for i := range longKey {
		longKey = string(append([]byte(longKey)[:i], 'a'))
	}

	longKeyMetadata := map[string]any{
		longKey: "value",
	}

	// Test with very long value (should fail if validation enforces value length limits)
	longValue := string(make([]byte, 3000)) // 3000 character value
	for i := range longValue {
		longValue = string(append([]byte(longValue)[:i], 'a'))
	}

	longValueMetadata := map[string]any{
		"key": longValue,
	}

	// These tests depend on the actual validation implementation
	// We're testing that the function doesn't panic and returns some result
	t.Run("very long key", func(_ *testing.T) {
		err := ValidateMetadata(longKeyMetadata)
		// Don't assert on the error result since validation rules may vary
		// Just ensure it doesn't panic
		_ = err
	})

	t.Run("very long value", func(_ *testing.T) {
		err := ValidateMetadata(longValueMetadata)
		// Don't assert on the error result since validation rules may vary
		// Just ensure it doesn't panic
		_ = err
	})
}

func TestFunctionsDontPanic(t *testing.T) {
	// Test that all functions handle edge cases without panicking
	t.Run("NewUUID doesn't panic", func(t *testing.T) {
		assert.NotPanics(t, func() {
			NewUUID()
		})
	})

	t.Run("IsValidUUID doesn't panic with various inputs", func(t *testing.T) {
		testInputs := []string{
			"",
			"invalid",
			"550e8400-e29b-41d4-a716-446655440000",
			"not-a-uuid-at-all",
			string(make([]byte, 1000)), // very long string
		}

		for _, input := range testInputs {
			assert.NotPanics(t, func() {
				IsValidUUID(input)
			}, "IsValidUUID should not panic with input: %s", input)
		}
	})

	t.Run("ValidateMetadata doesn't panic", func(t *testing.T) {
		testMetadata := []map[string]any{
			nil,
			{},
			{"key": "value"},
			{"key": nil},
			{"": ""},
			{string(make([]byte, 1000)): "value"},
		}

		for _, metadata := range testMetadata {
			assert.NotPanics(t, func() {
				ValidateMetadata(metadata)
			}, "ValidateMetadata should not panic with input: %v", metadata)
		}
	})
}

func TestUtilsIntegration(t *testing.T) {
	// Test that the utils work together correctly

	// Generate a UUID
	id := NewUUID()

	// Validate it
	assert.True(t, IsValidUUID(id), "Generated UUID should be valid")

	// Use it in metadata
	metadata := map[string]any{
		"id":          id,
		"description": "Test metadata with UUID",
		"count":       42,
	}

	// Validate metadata
	err := ValidateMetadata(metadata)
	require.NoError(t, err, "Metadata with UUID should be valid")
}

// Benchmark tests to ensure performance is reasonable
func BenchmarkNewUUID(b *testing.B) {
	for i := 0; i < b.N; i++ {
		NewUUID()
	}
}

func BenchmarkIsValidUUID(b *testing.B) {
	validUUID := "550e8400-e29b-41d4-a716-446655440000"
	invalidUUID := "not-a-uuid"

	b.Run("valid UUID", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			IsValidUUID(validUUID)
		}
	})

	b.Run("invalid UUID", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			IsValidUUID(invalidUUID)
		}
	})
}

func BenchmarkValidateMetadata(b *testing.B) {
	metadata := map[string]any{
		"key1": "value1",
		"key2": 42,
		"key3": true,
		"key4": "longer value with more text to test performance",
	}

	for i := 0; i < b.N; i++ {
		_ = ValidateMetadata(metadata)
	}
}
